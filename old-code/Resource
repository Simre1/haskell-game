{-# LANGUAGE TupleSections #-}
{-# LANGUAGE InstanceSigs #-}
module Resource where

import Import
import Sigma



-- data MaybeT (m :: * -> *) a where


-- data WithResource r (m :: * -> *) a where
--   GetRes :: WithResource r m r
--   FreeRes :: WithResource () m ()

-- makeSem ''WithResource

-- runWithResourceE :: Sem r a -> Sem r () -> Sem (WithResource a : r) (Maybe x) -> Sem r (Maybe x)
-- runWithResourceE getRes freeRes = interpret $ \case
--   GetRes -> getRes
--   FreeRes -> freeRes


-- runWithResource :: Resource (Sem r) v -> Signal (Sem (WithResource v : r)) a b -> Signal (Sem r) a b -> Signal (Sem r) a b
-- runWithResource res rSig cSig = Signal $ \a -> do
--   undefined

data ShouldFree = Free | NotFree deriving (Eq, Show)

withResourceMaybe :: Monad m => Resource m r -> (r -> Signal m a (Maybe b)) -> Signal m a b -> Signal m a b
withResourceMaybe (Resource g f t) s1 s2 = Signal $ \a -> do
  r <- g
  let signal s1' s2' = Signal $ \a' -> do
        (maybeB, cont) <- stepSignal s1' a'
        maybe
          (stepSignal (Signal $ \a'' -> f r >> stepSignal s2' a'') a')
          (pure . ( , signal cont s2'))
          maybeB
  stepSignal (signal (s1 $ t r) s2) a

withResource :: Monad m => Resource m r -> (r -> Signal m a (b,ShouldFree)) -> Signal m a b -> Signal m a b
withResource (Resource g f t) s1 s2 = Signal $ \a -> do
  r <- g
  let signal s1' s2' = Signal $ \a' -> do
        ((b,shouldFree), cont) <- stepSignal s1' a'
        cont' <- case shouldFree of
          Free -> f r *> pure s2'
          NotFree -> (pure $ signal cont s2')
        pure (b, cont')
  stepSignal (signal (s1 $ t r) s2) a

constantResource :: Monad m => Resource m r -> (r -> Signal m a b) -> Signal m a b
constantResource (Resource g _ t) sig = Signal $ \a -> do
  r <- g
  stepSignal (sig $ t r) a

data Resource m b = forall a. Resource {getResource :: m a, freeResource :: a -> m (),  transformResource :: a -> b}

newResource :: m a -> (a -> m ()) -> Resource m a
newResource g f = Resource g f id

instance Functor (Resource m) where
  fmap f (Resource ma am ab) = Resource ma am (f . ab)

instance Applicative m => Applicative (Resource m) where
  pure a = Resource (pure a) (const (pure ())) id
  (Resource get1 free1 trans1) <*> (Resource get2 free2 trans2) = Resource get free trans
    where get = (,) <$> get1 <*> get2
          free (a1,a2) = free1 a1 <* free2 a2
          trans (v1,v2) = trans1 v1 (trans2 v2)

morphResource :: (forall x. m x -> n x) -> Resource m a -> Resource n a
morphResource morph (Resource g f t) = Resource (morph g) (morph . f) t
