{-# LANGUAGE TemplateHaskell #-}

module Effect.SDLInput (SDLInput, sdlEvents, runSDLInput) where

import qualified SDL as SDL

import Import
import Sigma

import Data.Coerce

data SDLInput (m :: * -> *) k where
  SdlInput :: SDLInput m SDLInputData

newtype SDLInputData = SDLInputData {events :: [SDL.Event]}


makeSem ''SDLInput


runSDLInputE :: SDLInputData -> Sem (SDLInput : m) a -> Sem m a
runSDLInputE inputData = interpret $ \case
  SdlInput -> pure inputData

runSDLInput :: Member (Lift IO) m => Signal (Sem (SDLInput : m)) a b -> Signal (Sem m) a b
runSDLInput signal = Signal $ \a -> do
  events <- SDL.pollEvents
  (b, cont) <- runSDLInputE (SDLInputData events) $ stepSignal signal a
  return (b, runSDLInput cont)

sdlEvents :: (Member SDLInput r) => Sem r [SDL.Event]
sdlEvents = events <$> sdlInput

data SDLKeyboard (m :: * -> *) k where
  SDLKeyboardState :: SDLKeyboard m (SDL.Scancode -> Bool)

makeSem ''SDLKeyboard

runSDLKeyboard :: Member (Lift IO) r => Signal (Sem (SDLKeyboard : r)) a b -> Signal (Sem r) a b
runSDLKeyboard signal = Signal $ \a -> do
  keymap <- liftIO $ SDL.getKeyboardState
  (b, cont) <- runSDLKeyboardE keymap $ stepSignal signal a
  pure (b,runSDLKeyboard cont)

runSDLKeyboardE :: (SDL.Scancode -> Bool) -> Sem (SDLKeyboard : r) a -> Sem r a
runSDLKeyboardE a = interpret $ \case
  SDLKeyboardState -> pure a

